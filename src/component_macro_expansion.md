# Macro expansion

To better understand the `component` macro, we will examine how the different parts of the macro are translated into real Rust code (aka the macro expansion). Therefore, we will write a small app that uses as many component macro features as possible.

## The boilerplate

First, let's have a look at the parts of the code that are later used by the macro.

### The model

The model simply stores a counter.

```rust,ignore
{{#include ../examples/macro_reference.rs:model }}
```

### The message type

The message type is the same as in our first app. It includes a message to
increment and decrement the counter.

```rust,ignore
{{#include ../examples/macro_reference.rs:msg }}
```

## The macro

Before we break it down into smaller parts, let's take a look at the macro as a whole. If you're unfamiliar with macro syntax, check out the previous chapter. There's a lot here, but that's because the macro supports a lot of functions!

```rust,ignore
{{#include ../examples/macro_reference.rs:component }}
```

## The expansion

The macro expansion is not supposed to be readable, so the code might look a bit ugly.

### The widgets struct

The fields of the widgets struct cover all widgets we created, plus the additional fields we added manually. Named fields like `main_window` and `inc_button` keep their names. Unnamed fields will get automatically generated names with an unique ID. You should never refer to unnamed fields in your code because their names might change. At the end, we can find the additional field called `test_field` that we added manually.

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:widgets_struct }}
```

### The `SimpleComponent` trait implementation

The next thing the macro does is generating the `SimpleComponent` trait implementation block.

The start of the implementation block is very similar to the implementation block we use in the macro. Most notably, the `Root` type is automatically inserted, as is the implementation of `init_root`. All attributes and comments you add to the widget macro before the `impl` block should be kept as well.

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:widgets_impl }}
```

#### Initialization before the `view_output` entrypoint

A large part of the code generated by the macro is dedicated to the initialization of the view. This code is "expanded" from the `view_output!()` entrypoint. First, let's find the code we wrote before the entry point:

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:pre_init}}
```

Next, the macro initializes all widgets. Widgets defined by their type are initialized with their `Default` implementation. Any constructors or functions that are invoked manually are left unchanged in the output.

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:widget_init}}
```

#### Assigning properties

Assigning properties looks pretty normal as well. In the middle we have an optional assignment that uses an `if let` statement to only assign properties that match `Some(data)`. In the macro we marked this line with a `?`.

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:property_assign }}
```

#### Events

Now the macro generates the code for connecting events.

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:connect }}
```

The code looks very similar to what we wrote in the macro.

```rust,ignore
{{#include ../examples/macro_reference.rs:connect }}
```

Most notably, the sender we put in the square brackets is cloned as we requested.

#### Initialization after the `view_output` entrypoint

At the end we find the construction of the widgets struct and the construction of the `ComponentParts`, which was after the `view_output!` entrypoint.

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:post_init }}
```

#### UI updates

The last step of the macro is to generate the update logic within the `update_view` function. Any code present in the `pre_view` and `post_view` "functions" will be expanded before or after the generated code. Note that the generated code returns a private struct to prevent early returns in `pre_view` from skipping the rest of the view update code.

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:update_view}}
```

#### Generated UI updates

Within the generated update logic, the macro generates its own code to support more efficient updates.

Updates from the `#[watch]` attribute are unconditional.

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:watch }}
```

Updates from expressions annotated with `#[track]` are conditional based on whether the value changed, or based on if an expression is a certain value.

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:track }}
```

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:track_expression }}
```

## Conclusion

Congrats for making it this far ðŸŽ‰! You're now a real expert of Relm4!

As you have seen, the macro is nothing magical. It simply works with the information you give it.

## The whole macro expansion

If you want to look at the whole macro expansion at once, here it is.

```rust,ignore
{{#include ../examples/ignored/macro_expansion.rs:all }}
```
